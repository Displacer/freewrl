<TITLE>FreeWRL - Architecture</TITLE>

<H3>Architecture</H3>

<P>
&#35; Copyright (C) 1998 Tuomas J. Lukka, 1999, John Stewart CRC Canada.
<BR>&#35; DISTRIBUTED WITH NO WARRANTY, EXPRESS OR IMPLIED.
<BR>&#35; See the GNU Library General Public License (file COPYING in the distribution)
<BR>&#35; for conditions of use and redistribution, EXCEPT on the files
<BR>&#35; which belong under the mozilla public license.</P>


<P>Questions and answers about the browser architecture
(with help from Thomas Dudziak and Bernhard Reiter):</P>


<P><B>Q.</B> I want to help develop FreeWRL. Where do I start?</P>

<P><B>A.</B> 
Ask me (<A HREF="mailto:John.Stewart@crc.ca">John.Stewart@crc.ca</A>). I am the most up-to-date 
resource on open problems (development is quick so it's better
to coordinate than duplicate effort).</P>

<P>If you need background material,</P>

<P><B>VRML:</B></P>
<P><A HREF="http://www.vrml.org">http://www.vrml.org</A>, also get some good book if you need an introduction.</P>

<P><B>Perl:</B></P>
<P><A HREF="http://www.perl.com">http://www.perl.com</A> is the only place you'll ever need
to look: it contains links, book reviews and everything else.</P>

<P><B>OpenGL:</B> (the API used for rendering)</P>
<P> <A HREF="http://www.opengl.org">http://www.opengl.org</A>  -- links, book reviews, everything.</P>

<P><B>Computer graphics in general:</B></P>
<P>e.g. comp.graphics FAQ
<A HREF="ftp://rtfm.mit.edu/pub/usenet-by-hierarchy/comp/graphics/">ftp://rtfm.mit.edu/pub/usenet-by-hierarchy/comp/graphics/</A> </P>

<P>If you have additional recommendations for this section, please email me.</P>

       <BR>      
<P><B>Q.</B>  I was just curious about one thing : What is the benefit of using Perl
instead of a more let's say "usual" choice like C/C++ ? Why do you use
it ? To my experience, the code is even more complicated than C-source
(&#36;, &#64;, &#37; don't contribute to a good readability).</P>

<P><B>A.</B> Coding time. Do you really think one person could have finished
coding it all in this time, while trying to cope with random segfault,
long recompiles and whatever. My secret plan is trying to first achieve
spec compatibility and then maybe translating some of the modules
to other languages.</P>

<P>Perl is truly ideal for prototyping software. You get your things done
&#42;quickly&#42;. E.g. make a program that prints out its command-line arguments
separated by commas:</P>

<P>print join ',',&#64;ARGV;</P>

<P>whereas with c, you have to do loops, test when you need to print the comma
and whatever.</P>

<P>Just a simple example is the event structure: in VRMLNodes.pm, I just
do </P>

<P>&#36;f->{blahblah} = [3,1,2];</P>

<P>to send out a "blahblah" event from the node automatically to all
nodes ROUTEd or ISed from it.</P>

<P>The '&#36;&#37;&#64;/' are explained in the perl documentation -- after a couple
of days/weeks, they become a second nature, like 'a,the,...' in English.</P>

<BR>
            
<P><B>Q.</B> What's the overall structure of FreeWRL?</P>

<P><B>A.</B></P>

					
					<TABLE>
					<TR></TR>
<TD><DIV ALIGN="center">Parser</DIV></TD><TD></TD><TD></TD></TR>
<TR>
					  <TD><DIV ALIGN="center">|</DIV></TD><TD></TD><TD></TD></TR>
					  <TR>
<TD><DIV ALIGN="center">V</DIV></TD><TD></TD><TD></TD></TR>
				   <TR>
<TD>Scene Manager</TD>  <TD>.... Event model,</TD> <TD>node actions</TD></TR>
				   <TR>
<TD><DIV ALIGN="center">|</DIV></TD> <TD></TD>                              <TD><DIV ALIGN="center">|</DIV></TD></TR>
<TR>
<TD><DIV ALIGN="center">V</DIV></TD> <TD></TD>   <TD><DIV ALIGN="center">V</DIV></TD></TR>
<TR>
<TD><DIV ALIGN="center">Renderer</DIV></TD><TD></TD><TD><DIV ALIGN="center">Script interfaces</DIV></TD></TR>

</TABLE>
<BR>

<P><B>Q.</B> How do you parse the file, ie when and how do you create "objects" (in
terms of VRML)</P>

<P><B>A.</B> The file Parser.pm contains the top-level parse loop,
the function VRML::Parser::parse is the key. The way parsing works
is that the parser reads the file and calls the VRML::Scene object
which was passed to it to create nodes and such while parsing.
E.g. if you give the parser a file like
<BR>Transform {
<BR>translation 1 0 0
<BR>children [
<BR>Shape { geometry Box { } }
<BR>]
<BR>}</P>

<P>Then the parser calls the functions in the scene object like
(in exact perl syntax, i.e. [1,0,0] is an anonymous array etc.)
All types are translated into native Perl types for easy access.</P>

<P>&#36;a = &#36;$scene->new_node("Box", {});
&#36;b = &#36;scene->new_node("Shape", {geometry => &#36;a});
&#36;c = &#36;scene->new_node("Transform", {translation => [1,0,0], 
children  => [&#36;b]}); &#35; Notice children is an array reference (MFNode)
&#36;scene->topnodes([&#36;c]); &#35; Set which nodes were top-level in the scene.</P>

           <BR>

<P><B>Q.</B> How do you handle PROTOs ?</P>

<P><B>A.</B> This is currently a bit complicated and messy, I hope to rewrite it
a little later. The important file is Scene.pm</P>

<P>Once the scene has been created (this needs to be changed later
due to bindable nodes.. this is the way it is currently implemented),
I call the &#36;scene->make_executable method. This method iterates through
all the nodes of the scene and expands prototypes by placing the prototype
in the {ProtoExp} member of the node structure. VRML::Node::make_executable 
is where this happens. </P>

<P>Prototypes (and their instances) are actually represented internally
by the same structure that scenes are represented by (VRML::Scene).
This structure takes care of the name space of the instance.</P>

<BR>

<P><B>Q.</B> What is the internal handling of events ?</P>

<P><B>A.</B> This happens in Events.pm (duh ;) as well as Scene.pm.</P>

<P>Basically, the function VRML::EventMachine::propagate_events (Events.pm)
is called at each event timestamp.  This function first gets the
initial events from nodes and from mouse events, propagates the
event cascade, calls eventsProcessed and continues this until
no events remain.</P>

<P>Take note of the {RFields} member of a node -- this is a &#42;tied&#42;
hash (which looks like a normal perl hash (associative array) on top
but assignments to members and getting values of members translate
to function calls) tied with the class VRML::FieldHash (Scene.pm).
This takes care of IS and USE/DEF when getting/setting field values
as well as generating events when setting field values. The line</P>

<P>&#36;node->{EventModel}->put_event(&#36;node, &#36;k, &#36;value);</P>

<P>in the function VRML::FieldHash::STORE causes the new event to be queued
to be executed at the next step of the current event cascade.</P>

<P>Nodes receive events by the function VRML::Node::receive_event (Scene.pm)
which calls the function for that particular node (defined in VRMLNodes.pm)
to receive that event.</P>

<BR>


<P><B>Q.</B> Where and how is JavaScript/VrmlScript/Java connected ?</P>

<P><B>A.</B>  Continuing from the previous question, VRMLNodes.pm is the place where
the different node types receive events. In there, the Script node 
definition is the place to check. For Perl scripts, evaluation is 
done directly, compiling the subs into the {ScriptScript} member of 
the node, and for both JavaScript and Java, an object (the {J} member)
is used to deliver events. </P>

<P>The JavaScript interface is in the JS/ subdirectory and uses code 
from Mozilla(R/TM/whatever). The file JS.xs in that file is generated
by genJS.pl (see later about code generation)</P>

<P>FreeWRL currently interprets 'vrmlscript:' to be exactly equivalent
to 'javascript:'.</P>

<P>The Java interface resides in VRMLJava.pm (Perl side) 
and the java/ subdirectory (Java side). The interface is currently
through named pipes, with an ascii protocol for communication to make
it as easy as possible to use java. The file VRMLJava.pm spawns the
java interpreter and manages the protocol to use for communication.</P>

           <BR>

<P><B>Q.</B> What is VRMLC.pm, genJS.pl etc?</P>

<P><B>A.</B> FreeWRL uses extensive code generation to make programming convenient.
Instead of having to declare and use functions in many places and remember
everywhere what is happening at every other place, I only need to 
declare/define the way a node is rendered / renders its children in one
place. Also, the actual C types used to represent fields may change later
if I interface with other C modules so it is good to be able to change
them later.</P> 

<P>The way it works is simply that VRMLC.pm is a perl script (most
of the action happens at the end of the file) that prints the files
VRMLFunc.xs and VRMLFunc.pm as a result of running it. Some of the C code
is also in VRMLRend.pm. If the structure of these files is unclear, please
ask me.</P>

<BR>

<P><B>Q.</B> How do you handle Nodes for JavaScript and other languages?</P>

<P><B>A.</B> There is a package VRML::Handles in Browser.pm which provides 
simple string handles for nodes and ways to release them so that 
the garbage collection mechanisms of the different languages can be
unified without requiring scripting languages to be in the same process
and handle pointers.</P>

<P>Because that package stores a reference to the object in question,
that object will not be freed before the handle is released.</P>

<BR>

<P><B>Q.</B> Where is the implementation of the routines for the Browser object?</P>

<P><B>A.</B> In the file "Browser.pm", naturally ;) -- each scripting interface
calls these routines for the browser object.</P>

<BR> 

<P><B>Q.</B> How do you handle bindable nodes?</P>

<P><B>A.</B> In Scene.pm. When a node receives a set_bind event, if checks
for the special case in VRML::Node::receive_event and calls
VRML::Scene::set_bind in the same file, which manages the stack.</P>



<BR>
<P><B>Q.</B> On www-vrml: Steve Sycamore asking (>)</P>

<P>> Here are some thoughts about how you might be able to leverage the work you've
<BR>> done into a group which wants to have a generic, high performance, OS independ
ent,
<BR>> spec compliant and GPL'ed VRML plug-in:</P>

<P>Thank you for the thoughts!</P>

<P>> If you really believe Freewrl has acceptable performance, then publish some
<BR>> performance specs comparing it to CP 2.1 and WV 2.1.</P>

<P>Tell me how to make the comparation?</P>
<P>It's mighty fast on our department's SGI, somewhat slower on my laptop
(but that's due to no OpenGL acceleration).</P>

<P>Is there a benchmark somewhere I could try?</P>

<P>There are several optimizations still that I haven't done yet -
primary goal is compliance, performance is only second.</P>

<P>> Publish, in at least brief form, the general architecture of Freewrl, especial
ly noted
<BR>> the high level component design.  Show how a plan to replace Perl code in
<BR>> componentized modules with C++ or Java or both could be feasible!</P>

<P>It's at the FreeWRL home page, under "ARCHITECTURE".
<A HREF="http://www.crc.ca/FreeWRL">http://www.crc.ca/FreeWRL</A></P>

<P>The plan: the APIs between the different parts of the browser are simple
and don't transfer pointers, just names and VRML field values. 
Interfaceing Perl with other languages (C, ...) is trivial 
(just make a slightly modified function declaration and you can call it
from Perl).</P>

<P>> Show other frameworks which Mike Fletcher has identified could leverage parts
<BR>> of Freewrl or vice versa.</P>

<P>someone could take the parser and event model of freewrl (I still need
to clean up the interface between event model/backend a little, there
are two little warts there but nothing serious) and write a new backend
(e.g. in Direct3D), throw them together and have a browser.</P>

<P>The backend needs to be able to render either VRML97 nodes, without motion
or polygonal versions of them (e.g. Extrusion having been converted to
polygons).</P>

<P>> Maybe it makes sense to have Freewrl be the scaffolding which allows parts of
<BR>> a browser to be immediately available while other parts are being developed an
d
<BR>> tested.</P>

<P>I think it does. But I'm biased ;)</P>

<BR>



<P>Basic explanations of the architecture of the browser.</P>

<P>Node types are in VRMLNodes.pm
<BR>Parser.pm parses the code
<BR>Scene.pm takes care of the scene graph, PROTOs, DEF/USE, IS etc.
<BR>Events.pm takes care of all moving parts
<BR>GLBackEnd.pm renders and takes mouse events.
<BR>Viewer.pm takes care of navigation and viewpoint.</P>

<P> Each node has two different field hashes:
The member Fields is a normal hash with values that can refer
to IS'ed values, DEF/USE structs etc.
The member RFields is a tied hash which automatically dereferences
these and sends the proper events whenever a member is stored.</P>

<P>Assignment to individual members of fields is currently not allowed.</P>

<BR>

<P>There are three parts to this browser: the parser, the scene/event processor
and the backend (renderer).</P>

<P>It should be possible to easily replace any of these parts and/or
create character stream (e.g. socket) interfaces between the parts
and then use parts in other languages that communicate with parts
of this browser.</P>

<BR>
<P>Rendering backends are defined in a simple fashion:</P>

<P>1. there shall be implementations of all the VRML97 nodes
that render something or have children (group, transform,
geometry,...)</P>

<P>2. the backend is used via the functions</P>

<P>&#35; Initialization
<BR>&#36;a = VRML::BackEnd()...</P>

<P>&#35; Creating a new node
<BR>&#36;n = &#36;a->new_node("Cone", {a => b...}); </P>

<P>&#35; Setting fields in a node
<BR>&#36;a->set_fields(&#36;n, {a => b, c => d});</P> 

<P>&#35; Setting bindable nodes
<BR>&#36;a->set_root(&#36;n);
<BR>&#36;a->set_bindable(Which, $node);</P>

<P>&#35; HMM??
<BR>&#36;a->set_sensitive(&#36;n,click,over,sub); &#35; Are mouse hits / overs at &#36;n 
    <BR>&#35; to be recorded?</P>
						   
<P>&#36;a->delete_node(&#36;n); # It can be assumed that nothing will refer to &#36;n
    <BR>&#35; at this point.</P>

<P>For field types, the usual perl representations are used, except
for SFNode, (also inside MFNode) where the id received from the backend (&#36;n)
is used.</P>

<P>By defining the backend in this way, we will be able to call it over
a network or process limit or whatever.</P>

<P>The ids can then be C pointers or whatever.</P>


            <BR>
<P>Parser interface: the parser shall use the following routines:
Here, &#36;sc is either a file or a prototype.</P>

<P>&#35; Only explicitly specified fields provided
&#36;n = &#36;sc->new_node("Cone", {a => b, ...})</P> 

<P>&#35; Finally, set the top-level nodes of the file.
&#36;sc->topnodes([&#36;node1,&#36;node2,...]); &#35; Set the top-level nodes</P>

<P>&#35;DEF/USE
<BR>&#36;n = &#36;sc->new_def("FOO", &#36;node);
<BR>&#36;n = &#36;sc->new_use("FOO");</P>

<P>&#35; ROUTE
<BR>&#36;sc->new_route("FOO","bar","BAZ","quux");</P>

<P>&#35; Prototypes:
<BR>&#36;pr = &#36;sc->new_proto("MyProto",{par => [ftype,type,value]});
<BR>&#36;pr->new_node(...); &#35; Construct the prototype interface
<BR>&#36;pr->new_route(...); &#35; Construct the prototype interface
<BR>&#36;pr->topnodes(...); &#35; Set the top-level nodes</P>

<P>&#43; SOME</P>

<P>This interface will make it easy to define new VRML formats
(e.g. compressed binary) and plug them in.</P>

<BR>
<P>Currently inside the scenegraph: PROTO -> copy of implementation
as well as event model.</P>
