Routing, and the EAI and CLASS.

All are related. Routing info more at the end of this
document.


The EAI and CLASS invocation structure are similar, with
the exception of how routing works. One is a script, the
EAI is handled in a non-script way, which makes it simpler.
 
Work is progressing on how to make both EAI and CLASS
use the same routines for sending/receiving data.

What happens is this:

A socket is opened, initial exchange of data happens. If
this is a CLASS, the java class is found and invoked.
The main files are CFuncs/EAIServ.c and CFuncs/JavaClass.c

Events send data through this socket, in ASCII form. Commands
are read back in. For the EAI, it happens at the end of the
main loop (see, MainLoop.c), for CLASS, this happens when
EventsProcessed() is called. Both methods read all commands
from the java programs; for the EAI, this happens by reading
until the queue is empty, for the CLASS, all is read until
a FINISHED command is read.

VRML Variables are referenced via a perl NODE format, and via
an actual C pointer into memory. You'll see nodes come back
in the form 23:1233131, which is a handle to NODE23 in the
Perl side (check out the Handles in Browser.pm) and a pointer
to memory, as 1233131.

MF nodes are stored in the form (in memory) as tn->n - a count
of elements, and tn->p, a memory pointer for these elements.
Check out CFuncs/Structs.h (after a make - this is a generated
file) for node definitions.

So, say, EAI sends in an MFFloat containing 20 floats. This
is converted into binary into memory.  Then common routines
take the old pointer, if it has a value of 20, then a copy
happens; if not, it sets tn->n to 0, copys the memory to 
tn->p, then sets tn->n to 20.

ROUTING
-------

Nodes are identified by their C memory location. Offsets are
offsets from the start of this node; check out each node in
CFuncs/Structs.h for offsets. (c code is offsetof(struct SFBool, xxx))

Routing of MF values happens similarly to the blurb above concerning
MF stuff.

SF values are simply copied over (memcpy), with specific lengths
stored in the routing table. CFuncs/CRoutes.c is the main function.
eg, a copy of a float would be:
	memcpy (tonode+offset, fromnode+offset, sizeof(float)).

When a node is copied to, it is updated with "update_node(p)" which
tells the renderer that it has changed. (useful for re-generating 
shapes, etc)
	eg: update_node(tonode);

When something triggers a route, it calls "mark_event", which sets
a flag in the routing table. (eg, a Timer). The next time the table
is gone through, routes with this as a "from" are executed.

Interpolators are stored in the routing table. Actually, a pointer
to the interpolator function is stored; if something routes to an
interpolator, the data is copied, then the interpolator function
is called.

The routing table is gone through repeatedly until a clean pass through
happens - ie, no active routes.



